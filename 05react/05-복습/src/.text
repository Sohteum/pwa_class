징검다리역할.
root에 넣어주는거 그게 index.js



가상돔을 app.js에서 만들어서 계속 append를 해주는것

리액트는 파싱하는 순서에 관한 이벤트를 따로 제공함. 그래서 파싱 순서에 따른 이벤트는 프레임워크에서는 의미가 없다



리턴 안에서는 하나의 엘리먼트만 가능
그래서 하나로 싸주는걸 리액트프레그먼트라고 함.


변수가 바뀌었ㅡ\을때 화면이 바뀐다, 관련된 변수가 다 바뀐다. 그게 상태관리. state.
여기서는 사칙연산 밑에 input바뀌면 아래 애들이 다 바뀐다는거야 그러니까 편한거지

훅스는 컴포넌트 밖에서는 사용할 수 없다. 
안에서만 usestate 훅스를 사용할 수 있음
usestate는 배열을 리턴해주는 애인데
내가 구조분해를 하는거야. 구조분해문법임
배열이나 객체에서 값을 변수형태로 받아오는것.
변수형태로 갑을 쓰기 위한 방법

여기서 넘원을 그냥 바꿀수가 없음 그래서 변경할때는 무조건 셋넘원이라는 함수를 이용해서 바꾸어야만 바뀜
그래야 전부 관련된 애들이 바뀜

여기서는 넘원=5 이런거 의미없음

넘원은 화면 호출용, 셋넘원은 바꾸는용
넘원은 스테잇. 변수.
셋넘원은 스테잇을 바꾸는 함수



보간법 안에는 변수 하나만 들어갈 수 있음
내가 {num1+num2}이렇게 넣으면 두개냐구?아니야 더해서 결과값이 하나니까 하나임
그리고 문법같은거 적을수 없음


초기값을 비워넣고 
아래에서 셋넘원을 0으로 바꾼다면?
에러가 나옴.
왜?
굉장히 중요함
스테잇, 스테잇변경함수가 있자나
스테잇 변경함수는 화면을 바꾸라고 부탁하는거임. 그러니까 화면을 다시 읽는거야.
할일 끝나면 화면 다시 읽어서 바꾸ㅓ줘 이런거지.

처음에는 한번 렌더가 일어나고,
중간에 셋넘같은애들이 있으면 렌더링을 또해야되는구나 하고 밑으로 가서
처음부터 다시 읽고,
다시 중간에 셋넘을 만나서 렌더링을 또해야하는구나 하고 밑까지 렌더하고
다시 아까 렌더하라그랬지 하고 다시 렌더를 함
즉 무한 루프에 빠짐.

화면을 바꾸라는 부탁은 특정 이벤트에서만 해야함 그래야 에러를 안먹어.

1회성으로 해야함. 아니면 무한루프 빠짐.

리턴이라는게 끝나면서 딱!하고 끝



보간에서는 함수ㄹ이름만 넣음


state와 상관없는것만 밖에서 만들기

두가지 방법:
쿼리셀렉터 
유즈레퍼런스훅스

둘중에 하나 하기


조건부출력
증감연산자는 사용할 수 없다. 그니까 셋카운트를 바꾸려고 카운트를 사용할 수 없음
그래서 레이지이니셜라이징을 함

